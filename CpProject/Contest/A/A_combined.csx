using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Threading;
namespace CpLibrary.Contest
{
	public class SolverA : SolverBase
	{
		static void Main() => OnlineJudge.Run(new SolverA());

		public override void Solve()
		{
			var seg = new CpLibrary.Collections.Deque<int>();
		}

		public override void Init()
		{
			/*
			 * Write your init code here!
			 */
		}
	}
}
#region Expanded by https://github.com/kzrnm/SourceExpander
namespace CpLibrary.Collections { public class Deque<T> : IEnumerable<T> { int cur; T[] buffer; int mask; public int Count { get; private set; }  public Deque() : this(8) { }  public Deque(int capacity) { if (capacity != (capacity & -capacity)) { var t = capacity; capacity = 1; while (capacity < t) { capacity <<= 1; } }  mask = capacity - 1; buffer = new T[capacity]; cur = 0; Count = 0; }  public Deque(IEnumerable<T> items) : this(items.Count()) { var i = 0; foreach (var e in items) { buffer[i++] = e; }  Count = i; }  public T this[int index] { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => buffer[(index + cur) & mask]; [MethodImpl(MethodImplOptions.AggressiveInlining)] set { if (index < 0 || Count <= index) throw new IndexOutOfRangeException(); buffer[(index + cur) & mask] = value; } }  public void PushFront(T value) { if (buffer.Length == Count) Extend(); buffer[cur = ((cur + buffer.Length - 1) & mask)] = value; Count++; }  public void PushBack(T value) { if (buffer.Length == Count) Extend(); buffer[(cur + Count) & mask] = value; Count++; }  public T PopFront() { if (Count == 0) throw new InvalidOperationException("Deque contains no elements."); var ret = buffer[cur]; cur = ++cur & mask; Count--; return ret; }  public T PopBack() { if (Count == 0) throw new InvalidOperationException("Deque contains no elements."); var ret = buffer[(cur + --Count) & mask]; return ret; }  public T Front => this[0]; public T Back => this[Count - 1];  public void Clear() { Count = 0; buffer = new T[8]; cur = 0; mask = buffer.Length - 1; }  private void Extend() { var newBuffer = new T[buffer.Length * 2]; for (int i = 0; i < buffer.Length; i++) { newBuffer[i] = this[i]; }  mask = newBuffer.Length - 1; cur = 0; buffer = newBuffer; }  public void AddAt(int index, T value) { if (index < 0 || Count < index) throw new IndexOutOfRangeException(); if (index < Count / 2) { PushFront(value); for (int i = 0; i < index; i++) { this[i] = this[i + 1]; }  this[index] = value; } else { PushBack(value); for (int i = Count - 1; i >= index; i--) { this[i] = this[i - 1]; }  this[index] = value; } }  public T RemoveAt(int index) { if (index < 0 || Count <= index) throw new IndexOutOfRangeException(); var ret = this[index]; if (index < Count / 2) { for (int i = index - 1; i >= 0; i--) { this[i + 1] = this[i]; }  PopFront(); } else { for (int i = index; i < Count - 1; i++) { this[i] = this[i + 1]; }  PopBack(); }  return ret; }  System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => this.GetEnumerator(); public IEnumerator<T> GetEnumerator() { for (int i = 0; i < Count; i++) { yield return this[i]; } }  public T[] Items { get { var ret = new T[Count]; for (int i = 0; i < Count; i++) { ret[i] = this[i]; }  return ret; } } } }
namespace CpLibrary { public class Scanner { public StreamReader sr { get; private set; }  string[] str; int index; char[] separators; public Scanner(StreamReader sr, char[] separators) { this.sr = sr; this.separators = separators; str = new string[0]; index = 0; }  public Scanner(StreamReader sr) : this(sr, new char[] { ' ' }) { }  public Scanner() : this(new StreamReader(Console.OpenStandardInput()), new char[] { ' ' }) { }  public string Read() { if (index < str.Length) return str[index++]; string s; do s = sr.ReadLine(); while (s == ""); str = s.Split(separators, StringSplitOptions.RemoveEmptyEntries); index = 0; return str[index++]; }  public string ReadString() => Read(); public string[] ReadStringArray(int n) { var arr = new string[n]; for (int i = 0; i < n; i++) { arr[i] = ReadString(); }  return arr; }  public int ReadInt() => int.Parse(ReadString()); public int[] ReadIntArray(int n) => ReadValueArray<int>(n); public long ReadLong() => long.Parse(ReadString()); public long[] ReadLongArray(int n) => ReadValueArray<long>(n); public double ReadDouble() => double.Parse(ReadString()); public double[] ReadDoubleArray(int n) => ReadValueArray<double>(n); public BigInteger ReadBigInteger() => BigInteger.Parse(ReadString()); public T1 ReadValue<T1>() => (T1)Convert.ChangeType(ReadString(), typeof(T1)); public (T1, T2) ReadValue<T1, T2>() => (ReadValue<T1>(), ReadValue<T2>()); public (T1, T2, T3) ReadValue<T1, T2, T3>() => (ReadValue<T1>(), ReadValue<T2>(), ReadValue<T3>()); public (T1, T2, T3, T4) ReadValue<T1, T2, T3, T4>() => (ReadValue<T1>(), ReadValue<T2>(), ReadValue<T3>(), ReadValue<T4>()); public (T1, T2, T3, T4, T5) ReadValue<T1, T2, T3, T4, T5>() => (ReadValue<T1>(), ReadValue<T2>(), ReadValue<T3>(), ReadValue<T4>(), ReadValue<T5>()); public (T1, T2, T3, T4, T5, T6) ReadValue<T1, T2, T3, T4, T5, T6>() => (ReadValue<T1>(), ReadValue<T2>(), ReadValue<T3>(), ReadValue<T4>(), ReadValue<T5>(), ReadValue<T6>()); public (T1, T2, T3, T4, T5, T6, T7) ReadValue<T1, T2, T3, T4, T5, T6, T7>() => (ReadValue<T1>(), ReadValue<T2>(), ReadValue<T3>(), ReadValue<T4>(), ReadValue<T5>(), ReadValue<T6>(), ReadValue<T7>()); public T1[] ReadValueArray<T1>(int n) { var arr = new T1[n]; for (int i = 0; i < n; i++) { arr[i] = ReadValue<T1>(); }  return arr; }  public (T1[], T2[]) ReadValueArray<T1, T2>(int n) { var(v1, v2) = (new T1[n], new T2[n]); for (int i = 0; i < n; i++) { (v1[i], v2[i]) = ReadValue<T1, T2>(); }  return (v1, v2); }  public (T1[], T2[], T3[]) ReadValueArray<T1, T2, T3>(int n) { var(v1, v2, v3) = (new T1[n], new T2[n], new T3[n]); for (int i = 0; i < n; i++) { (v1[i], v2[i], v3[i]) = ReadValue<T1, T2, T3>(); }  return (v1, v2, v3); }  public (T1[], T2[], T3[], T4[]) ReadValueArray<T1, T2, T3, T4>(int n) { var(v1, v2, v3, v4) = (new T1[n], new T2[n], new T3[n], new T4[n]); for (int i = 0; i < n; i++) { (v1[i], v2[i], v3[i], v4[i]) = ReadValue<T1, T2, T3, T4>(); }  return (v1, v2, v3, v4); }  public (T1[], T2[], T3[], T4[], T5[]) ReadValueArray<T1, T2, T3, T4, T5>(int n) { var(v1, v2, v3, v4, v5) = (new T1[n], new T2[n], new T3[n], new T4[n], new T5[n]); for (int i = 0; i < n; i++) { (v1[i], v2[i], v3[i], v4[i], v5[i]) = ReadValue<T1, T2, T3, T4, T5>(); }  return (v1, v2, v3, v4, v5); }  public (T1[], T2[], T3[], T4[], T5[], T6[]) ReadValueArray<T1, T2, T3, T4, T5, T6>(int n) { var(v1, v2, v3, v4, v5, v6) = (new T1[n], new T2[n], new T3[n], new T4[n], new T5[n], new T6[n]); for (int i = 0; i < n; i++) { (v1[i], v2[i], v3[i], v4[i], v5[i], v6[i]) = ReadValue<T1, T2, T3, T4, T5, T6>(); }  return (v1, v2, v3, v4, v5, v6); }  public (T1[], T2[], T3[], T4[], T5[], T6[], T7[]) ReadValueArray<T1, T2, T3, T4, T5, T6, T7>(int n) { var(v1, v2, v3, v4, v5, v6, v7) = (new T1[n], new T2[n], new T3[n], new T4[n], new T5[n], new T6[n], new T7[n]); for (int i = 0; i < n; i++) { (v1[i], v2[i], v3[i], v4[i], v5[i], v6[i], v7[i]) = ReadValue<T1, T2, T3, T4, T5, T6, T7>(); }  return (v1, v2, v3, v4, v5, v6, v7); }  public (T1, T2)[] ReadTupleArray<T1, T2>(int n) { var ret = new (T1, T2)[n]; for (int i = 0; i < n; i++) { ret[i] = ReadValue<T1, T2>(); }  return ret; }  public (T1, T2, T3)[] ReadTupleArray<T1, T2, T3>(int n) { var ret = new (T1, T2, T3)[n]; for (int i = 0; i < n; i++) { ret[i] = ReadValue<T1, T2, T3>(); }  return ret; }  public (T1, T2, T3, T4)[] ReadTupleArray<T1, T2, T3, T4>(int n) { var ret = new (T1, T2, T3, T4)[n]; for (int i = 0; i < n; i++) { ret[i] = ReadValue<T1, T2, T3, T4>(); }  return ret; }  public (T1, T2, T3, T4, T5)[] ReadTupleArray<T1, T2, T3, T4, T5>(int n) { var ret = new (T1, T2, T3, T4, T5)[n]; for (int i = 0; i < n; i++) { ret[i] = ReadValue<T1, T2, T3, T4, T5>(); }  return ret; }  public (T1, T2, T3, T4, T5, T6)[] ReadTupleArray<T1, T2, T3, T4, T5, T6>(int n) { var ret = new (T1, T2, T3, T4, T5, T6)[n]; for (int i = 0; i < n; i++) { ret[i] = ReadValue<T1, T2, T3, T4, T5, T6>(); }  return ret; }  public (T1, T2, T3, T4, T5, T6, T7)[] ReadTupleArray<T1, T2, T3, T4, T5, T6, T7>(int n) { var ret = new (T1, T2, T3, T4, T5, T6, T7)[n]; for (int i = 0; i < n; i++) { ret[i] = ReadValue<T1, T2, T3, T4, T5, T6, T7>(); }  return ret; } } }
namespace CpLibrary { public abstract class SolverBase { public bool StartsOnThread { get; set; } = false; public int Testcases { get; set; } = 1;  public Scanner scanner; public StreamWriter writer; public abstract void Init(); public abstract void Solve(); public void Run(StreamReader reader, StreamWriter writer) { this.writer = writer; scanner = new Scanner(reader); Console.SetOut(writer); if (StartsOnThread) { var thread = new Thread(new ThreadStart(RunInternal), 1 << 27); thread.Start(); thread.Join(); } else { RunInternal(); } }  void RunInternal() { Init(); var testcases = Testcases; while (testcases-- > 0) { Solve(); } } }  public static partial class OnlineJudge { public static void Run(SolverBase solver) { var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; var sr = new StreamReader(Console.OpenStandardInput()); solver.Run(sr, sw); Console.Out.Flush(); } } }
#endregion Expanded by https://github.com/kzrnm/SourceExpander
